# DANGA (danga.site) — Vibe Coding A~Z 진행 문서

## Part 8: 랭킹(주간/월간) + 퍼센타일 뱃지(상위 1%~10%) + 집계 전략(MVP)

> Part 8 목표는 “커뮤니티의 게임화(랭킹/뱃지)”를 붙여서 재방문과 경쟁 심리를 만드는 것입니다.  
> 이 파트에서 **/rank 페이지가 실제 데이터로 돌아가고**, 게시글 카드에도 “등급/뱃지”가 보이게 합니다.

---

## 0. 전제(Part 7까지 완료)

- ✅ posts: 작성/피드/상세 + soft delete(deleted_at)
- ✅ votes: 좋아요 토글 + 중복 방지
- ✅ comments: 작성/조회/soft delete
- ✅ profiles: nickname/avatar_url/role
- ✅ 배포 환경(danga.site)에서 동작 확인 가능

---

## 1. Part 8 목표

1. `/rank` 페이지 구현(실데이터)
   - **주간 랭킹**, **월간 랭킹** 탭/토글
2. 랭킹 기준: 좋아요 수(votes count)
3. “상위 퍼센타일 뱃지” 계산
   - 예: Top 1%, Top 5%, Top 10% (MVP는 1/10만 해도 OK)
4. 게시글 카드(feed/detail)에 뱃지 표시(선택)
5. 집계 방식(MVP):
   - **SQL View(뷰)** 로 계산해서 프론트에서 조회
   - 데이터 커지면 배치/캐시 컬럼으로 확장(Part 8.5/9)

---

## 2. 랭킹 기준 정의(MVP 확정)

### 2.1 점수(Score)

- `score = 해당 기간 내 votes 개수`
- 게시글이 삭제(soft delete)된 경우 제외:
  - `posts.deleted_at is null`

### 2.2 기간(week/month) 정의

- 주간: “이번 주(월~일)”
- 월간: “이번 달(1~말일)”
- 기간 기준은 votes.created_at을 기준으로 함(좋아요가 모인 시점)

> 단순화:  
> “그 주/달에 받은 좋아요 수”로 랭킹 매김  
> (게시글 작성일이 아니라 ‘반응 받은 기간’이 기준)

---

## 3. DB 설계: 집계 뷰(View) 2개

- `weekly_post_rankings`
- `monthly_post_rankings`

각 뷰에는 최소로 아래 필드를 제공:

- post_id
- score
- rank (1..N)
- percentile (0~100 또는 0~1)
- badge (예: 'TOP_1', 'TOP_10', null)
- created_at/참조용 필드(선택)

---

## 4. Supabase SQL (Part 8) — 복붙 실행용

> Supabase SQL Editor에서 그대로 Run  
> ⚠️ `date_trunc`는 UTC 기준일 수 있습니다. 운영에서 KST 기준이 중요하면 Part 8.5에서 타임존 정교화.

### 4.1 주간 랭킹 뷰

```sql
create or replace view public.weekly_post_rankings as
with base as (
  select
    p.id as post_id,
    count(v.post_id)::int as score
  from public.posts p
  left join public.votes v
    on v.post_id = p.id
   and v.created_at >= date_trunc('week', now())
   and v.created_at <  date_trunc('week', now()) + interval '7 days'
  where p.deleted_at is null
  group by p.id
),
ranked as (
  select
    post_id,
    score,
    dense_rank() over (order by score desc, post_id asc) as rank,
    count(*) over () as total
  from base
)
select
  post_id,
  score,
  rank,
  total,
  (rank::numeric / nullif(total,0)) as percentile_ratio,
  case
    when (rank::numeric / nullif(total,0)) <= 0.01 then 'TOP_1'
    when (rank::numeric / nullif(total,0)) <= 0.10 then 'TOP_10'
    else null
  end as badge
from ranked;



create or replace view public.monthly_post_rankings as
with base as (
  select
    p.id as post_id,
    count(v.post_id)::int as score
  from public.posts p
  left join public.votes v
    on v.post_id = p.id
   and v.created_at >= date_trunc('month', now())
   and v.created_at <  date_trunc('month', now()) + interval '1 month'
  where p.deleted_at is null
  group by p.id
),
ranked as (
  select
    post_id,
    score,
    dense_rank() over (order by score desc, post_id asc) as rank,
    count(*) over () as total
  from base
)
select
  post_id,
  score,
  rank,
  total,
  (rank::numeric / nullif(total,0)) as percentile_ratio,
  case
    when (rank::numeric / nullif(total,0)) <= 0.01 then 'TOP_1'
    when (rank::numeric / nullif(total,0)) <= 0.10 then 'TOP_10'
    else null
  end as badge
from ranked;
```
