# DANGA (danga.site) — Vibe Coding A~Z 진행 문서

## Part 14(선택): 알림(Notifications) MVP — 댓글/좋아요/신고 처리 알림 + 읽음 처리

> Part 14는 “재방문”을 강하게 만드는 기능입니다.  
> MVP는 푸시/이메일까지 가지 않고, **앱 내부 알림(in-app)** 만 구현합니다.  
> (이메일/푸시는 Part 14.5에서 확장)

---

## 0. 전제(Part 13까지 완료)

- ✅ 런칭 체크리스트 통과(SEO/정책/성능 기본)
- ✅ posts/votes/comments/reports/admin/logging
- ✅ 운영(danga.site) 안정화

---

## 1. Part 14 목표(MVP)

1. `notifications` 테이블 생성
2. 알림 생성 트리거/로직(서버에서)
   - 누군가 내 게시글에 좋아요 → 알림
   - 누군가 내 게시글에 댓글 → 알림
   - 내가 신고한 건에 대해 admin이 처리(resolved/rejected) → 알림(선택)
3. 헤더에 알림 아이콘 + 뱃지(count)
4. `/notifications` 페이지:
   - 알림 리스트
   - 클릭 시 해당 대상으로 이동(`/p/[id]`)
   - 읽음 처리

---

## 2. 알림 설계

### 2.1 notifications 테이블(최소)

- id uuid pk
- user_id uuid (알림 받는 사람)
- type text ('vote' | 'comment' | 'report_update')
- actor_id uuid nullable (행동한 사람)
- post_id uuid nullable
- comment_id uuid nullable
- report_id uuid nullable
- message text
- is_read boolean default false
- created_at timestamptz

### 2.2 RLS

- select: 본인(user_id=auth.uid())만
- insert: 서버/RPC로만(권장) 또는 policy로 제한
- update: 본인만(is_read true)
- delete: 본인만(선택)

> 추천: insert는 SECURITY DEFINER 함수로만 하자(클라 조작 방지)

---

## 3. 알림 생성 로직(MVP 권장)

### 3.1 언제 생성?

- vote insert 성공 시:
  - 해당 post의 작성자(user_id)를 찾아서 알림 생성(본인 제외)
- comment insert 성공 시:
  - post 작성자에게 알림 생성(본인 제외)
- report status update 시(선택):
  - reporter에게 결과 알림 생성

### 3.2 어디서 생성?

- 프론트에서 직접 insert ❌(권장하지 않음)
- 서버 API route 또는 RPC 함수에서 생성 ✅

> 이유: 악성 유저가 알림을 스팸으로 찍을 수 있음.

---

## 4. Supabase SQL (Part 14) — 복붙 실행용

### 4.1 notifications 테이블 + RLS

```sql
create table if not exists public.notifications (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  type text not null check (type in ('vote','comment','report_update')),
  actor_id uuid references auth.users(id) on delete set null,
  post_id uuid references public.posts(id) on delete cascade,
  comment_id uuid references public.comments(id) on delete cascade,
  report_id uuid references public.reports(id) on delete cascade,
  message text not null,
  is_read boolean not null default false,
  created_at timestamptz default now()
);

create index if not exists notifications_user_created_idx
on public.notifications (user_id, created_at desc);

alter table public.notifications enable row level security;

-- 본인 알림만 조회
create policy "notifications_select_own"
on public.notifications for select
using (auth.uid() = user_id);

-- 본인만 읽음 처리
create policy "notifications_update_own"
on public.notifications for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

-- (선택) 본인만 삭제
create policy "notifications_delete_own"
on public.notifications for delete
using (auth.uid() = user_id);


create or replace function public.notify_vote(p_post_id uuid, p_actor_id uuid)
returns void
language plpgsql
security definer
as $$
declare
  owner_id uuid;
begin
  select user_id into owner_id from public.posts where id = p_post_id and deleted_at is null;
  if owner_id is null then return; end if;
  if owner_id = p_actor_id then return; end if;

  insert into public.notifications(user_id, type, actor_id, post_id, message)
  values (owner_id, 'vote', p_actor_id, p_post_id, '누군가 내 게시글에 좋아요를 눌렀어요.');
end;
$$;

create or replace function public.notify_comment(p_post_id uuid, p_comment_id uuid, p_actor_id uuid)
returns void
language plpgsql
security definer
as $$
declare
  owner_id uuid;
begin
  select user_id into owner_id from public.posts where id = p_post_id and deleted_at is null;
  if owner_id is null then return; end if;
  if owner_id = p_actor_id then return; end if;

  insert into public.notifications(user_id, type, actor_id, post_id, comment_id, message)
  values (owner_id, 'comment', p_actor_id, p_post_id, p_comment_id, '누군가 내 게시글에 댓글을 남겼어요.');
end;
$$;

```
